/*
 * Copyright (c) 2022 Samsung Electronics Co., Ltd. All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as vscode from 'vscode';
import fs from 'fs';
import * as crypto from 'crypto';

/**
 * A Singleton Object
 * 
 * PathToHash is a data structure that stores the path of the actual data 
 * and the hash value generated by the contents of the actual data
 * to synchronize the actual data and metadata
 */

class SyncMetadata{
  static async validateMetadata(flattenMap: any) {

    /**  1. Create metadata if pathToHash exists but does not have actual metadata files,
     *      If pathToHash exists and there is a actual metadata file, but there is no path inside, create
     *      a path and data insde
     */
    await this.createMetadata(flattenMap);

    // 2. Replace is_deleted with true for all metadata not in pathToHash
    await this.deleteMetadata(flattenMap);
  }

  static async createMetadata(flattenMap: any) {
    for (let path in flattenMap) {
      const hash = flattenMap[path];


      // It will probably be replaced by the code of the Metadata module from here
      // maybe Metadata.create(hash)
      let metadata: any = await Metadata.get(hash);

      if (Object.keys(metadata).length === 0) {
        await Metadata.set(hash, {});

      } else if (metadata[path]) {
        return;
      }

      const filename: any = path.split('/').pop();
      if (vscode.workspace.workspaceFolders === undefined) {
        return;
      }
      const stats: any = await Metadata.getStats(
          vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, path));
      metadata[path] = {};
      metadata[path]['name'] = filename;
      metadata[path]['file-extension'] = filename.split('.')[1];
      metadata[path]['create-time'] = stats.birthtime;
      metadata[path]['modified-time'] = stats.mtime;
      metadata[path]['is-deleted'] = false;
      await Metadata.set(hash, metadata);

      // to here
    }
  }

  static async deleteMetadata(flattenMap: any) {
    if (vscode.workspace.workspaceFolders === undefined) {
      return;
    }
    const baseUri =
        vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, '.meta/hash_objects');
    const files = await vscode.workspace.fs.readDirectory(baseUri);
    for (const file of files) {
      const hashFolderUri = vscode.Uri.joinPath(baseUri, file[0]);
      const hashList = await vscode.workspace.fs.readDirectory(hashFolderUri);
      for (const hashFile of hashList) {
        const hashUri = vscode.Uri.joinPath(hashFolderUri, hashFile[0]);
        let metadata =
            JSON.parse(Buffer.from(await vscode.workspace.fs.readFile(hashUri)).toString());
        const hash = file[0] + hashFile[0].split('.')[0];
        for (const key in metadata) {
          if (!metadata[key]['is-deleted'] && flattenMap[key] !== hash) {
            metadata[key]['is-deleted'] = true;
          }
        }
        Metadata.set(hash, metadata);
      }
    }
  }
}

export class PathToHash {
  private static _instance: PathToHash;
  private _map: any;

  private constructor() {}

  public static async getInstance() {
    if (!this._instance) {
      this._instance = new PathToHash();
      this._instance._map = await this._instance.init();
      await SyncMetadata.validateMetadata(await this._instance.getFlatMap());
    }
    return this._instance;
  }

  private async init() {
    if (vscode.workspace.workspaceFolders === undefined) {
      return;
    }
    const uri = vscode.workspace.workspaceFolders[0].uri;

    return this.scanRecursively(uri);
  }

  private async scanRecursively(uri: vscode.Uri) {
    let subMap: {[key: string]: any} = {};
    const files = await vscode.workspace.fs.readDirectory(uri);

    for (const file of files) {
      const name: string = file[0];
      const type: number = file[1];

      if (type === 1) {
        subMap[name] = await PathToHash.generateHash(vscode.Uri.joinPath(uri, '/' + name));
      } else if (type === 2 && name !== '.meta') {
        subMap[name] = await this.scanRecursively(vscode.Uri.joinPath(uri, '/' + name));
      }
    }
    if(subMap === {}) {
      return;
    }

    return subMap;
  }

  async getFlatMap() {
    let flatMap: any = {};
    let map = this._map;
    let queue = [];
    for (let data in map) {
      queue.push([data, map[data], data.toString()]);
    }

    while (queue.length !== 0) {
      const subMap = queue.pop();
      if (subMap === undefined) {
        continue;
      }
      if (vscode.workspace.workspaceFolders === undefined) {
        break;
      }
      let path =
          vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, subMap[2]).path;
      if (fs.lstatSync(path).isDirectory()) {
        for (let key in subMap[1]) {
          queue.push([key, subMap[1][key], subMap[2] + '/' + key]);
        }
      } else {
        flatMap[subMap[2]] = subMap[1];
      }
    }
    return flatMap;
  }


  /**
   * 
   * @param uri 
   * @returns hash :string
   * @brief put uri in the '_map' to get a hash
   */
  get(uri: vscode.Uri) {
    const splitPath = vscode.workspace.asRelativePath(uri).split('/');
    let map = this._map;

    splitPath.forEach((path) => {
      if (map === undefined) {
        return undefined;
      }
      map = map[path];
    });

    return map;
  }

  getFilesUnderFolder(uri: vscode.Uri) {
    const folder = this.get(uri);
    const files: vscode.Uri[] = [];
    if (typeof (folder) === 'string') {
      // not a folder
      return files;
    }
    for (const name in folder) {
      files.push(vscode.Uri.joinPath(uri, name));
    }

    return files;
  }

  /**
   * @brief Input uri, extract path and hash values, and store them in a '_map'
   */  
  async add(uri: vscode.Uri) {
    const path = vscode.workspace.asRelativePath(uri);
    const paths = path.split('/');
    let content: any = await PathToHash.generateHash(uri);
    let subMap = this._map;
    let idx = 0;
    for (let path = paths[idx]; idx < paths.length - 1; path = paths[++idx]) {
      if (!subMap[path]) {
        break;
      }
      subMap = subMap[path];
    }
    if (paths.length - 1 === idx) {  // paths.length - 1: index of a file name
      // When all of the folder path are stored in pathToHash
      // update / create pathToHash for a file
      subMap[paths[idx]] = content;
      return;
    }

    for (let i = paths.length - 1; i > idx; --i) {
      let tempContent: {[key: string]: any} = {};
      tempContent[paths[i]] = content;
      content = tempContent;
    }
    subMap[paths[idx]] = content;
}

  /**
   * @param uri 
   * @brief Input uri, extract path and hash values, and delete them in a '_map'
   */
  delete(uri: vscode.Uri) {
    let subMap = this._map;
    const splitPath = vscode.workspace.asRelativePath(uri).split('/');

    for (let i = 0, path = splitPath[i]; i < splitPath.length - 1; path = splitPath[++i]) {
      if (!subMap) {
        return;
      }
      subMap = subMap[path];
    }
    if (subMap === undefined) {
      // already deleted
      return;
    }
    delete subMap[splitPath[splitPath.length - 1]];
    if (splitPath.length > 1) {
      this.deleteEmptyDirPath(this._map, splitPath, 0);
    }
  }

  /**
   * 
   * @param parent 
   * @param paths 
   * @param idx 
   * @brief delete Empty directory path from '_map'
   */
  deleteEmptyDirPath(parent: any, paths: string[], idx: number) {
    const path = paths[idx];
    if (paths.length - 2 === idx) {
      if (Object.keys(parent[path]).length === 0) {
        delete parent[path];
      }
      return;
    }
    if (parent[path] === undefined) {
      return;
    }
    this.deleteEmptyDirPath(parent[path], paths, idx + 1);
    if (Object.keys(parent[path]).length === 0) {
      delete parent[path];
    }
  }

  // this function will probably be separated by Util
  public static async generateHash(uri: vscode.Uri) {
    // TODO: Error handling
    return crypto.createHash('sha256')
        .update(Buffer.from(await vscode.workspace.fs.readFile(uri)).toString())
        .digest('hex');
  }
}